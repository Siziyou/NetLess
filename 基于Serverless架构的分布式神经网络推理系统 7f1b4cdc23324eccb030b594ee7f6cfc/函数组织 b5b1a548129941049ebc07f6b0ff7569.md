# 函数组织

### 异步还是同步

由于存在多个模型，且模型互为生产者、消费者，因此怎么组织工作流就成了问题。

同步模式下的伪代码为：

```python
def fn(req):
	res1=model1(req)
	res2=fn2(res1)
	res3=fn3(res2)
......
	return res_final
```

这种组织方式下，当fn2、fn3的过程没有执行完毕，那么fn1将进入阻塞状态，并没有利用起来，本质上并没有提升资源的时间利用率。

因此最佳的组织方式应该为异步模式，即单独部署各个模型函数：

```python
def fn1(req)
	return model1.eval(req)
def fn2(req)
	return model2.eval(req)
......
```

并通过设置，编排异步工作流，使得工作流像流水线一样持续运行，以此提升资源的利用率。

问题就在于，异步组织必然会要求进行“负载均衡”。虽然severless会自动进行弹性编排来保证不产生拥塞，但是如果在拆解模型时，能够均衡拆解出参数量相仿的几个子模型，显然整体运行速度会更快些

---

### OpenFass CLI使用简介

可以使用以下命令安装 OpenFaaS CLI：

```
curl -sSL <https://cli.openfaas.com> | sudo sh
```

安装完成后，可以使用以下命令登录到 OpenFaaS 控制台：

```
export OPENFAAS_URL=http://127.0.0.1:8080
echo -n PASSWORD | faas-cli login --username admin --password-stdin
```

其中，`OPENFAAS_URL` 是部署 OpenFaaS 的 URL 地址，`PASSWORD` 是在安装时设置的密码。

登录后，可以使用 `faas-cli` 命令创建和管理函数，如下所示：

```
faas-cli new <function-name> --lang <language>
faas-cli build -f <stack-file>
faas-cli deploy -f <stack-file>
```

---

### openfass中的异步工作流

讨论异步工作流之前，首先说明openfass的同步和异步。

在openfass中，同步的实现方式十分简单，其实就是前文提到的，函数内调用另一个函数即可。只是“调用”操作需要用request的方式进行，即访问内部地址”/func/<your-function-name>”，进行调用（invoke）。这样在后续数据返回之前，函数将暂时处于阻塞状态。函数返回后，用户会收到result。

而异步的实现方式稍微复杂，在openfass中，可以使用一个消息队列系统NATS。该队列将会容纳异步函数提交的任务以及信息，就像一个冒险者任务中心，worker发布任务到这里，deworker来这里领取任务。

---

以下给一个简单的流程说明：

使用NATS作为消息队列，可以使用以下命令创建一个新的异步函数模板：

```bash
faas-cli new --lang python3-async --prefix="my-async-workflow" my-async-function
```

然后，可以在**`stack.yml`**文件中定义一个包含多个异步函数的堆栈，例如：

```yaml
provider:
  name: openfaas
  gateway: http://localhost:8080

functions:
  worker-1:
    lang: python3-async
    handler: ./worker-1
    async: true
  worker-2:
    lang: python3-async
    handler: ./worker-2
    async: true
  worker-3:
    lang: python3-async
    handler: ./worker-3
    async: true

async_hooks:
  - source: worker-1
    destination: worker-2
  - source: worker-2
    destination: worker-3
```

单独看上面的yaml就能很清晰看到函数之间的依赖关系，谁是生产者谁是消费者一目了然。

接下来具体到某一代码文件的编写，下面展示一个示例：

```python
import asyncio

async def async_function(input_data):
    await asyncio.sleep(1)
    output_data = input_data.upper()
    return output_data
```

然后开始准备打包镜像：

```docker
FROM python:3.8-slim-buster

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY function/ .

ENV fprocess="python3 main.py"

CMD ["fwatchdog"]
```

注意，其中requirement记得写清楚要安装asyncio~

之后开始部署：

```bash
faas-cli build -f myfunction.yml
faas-cli push -f myfunction.yml
faas-cli deploy -f myfunction.yml
```

最后调用：

```bash
echo "hello world" | faas-cli invoke myfunction
```

---

这种实现方法非常朴素并且很依赖程序员自身的设计功力，为了实现对神经网络模型的自动化，还需要更高效的方式。（也就是嫖更好的轮子）

因此我们选用了更合适的faas-flow插件，该插件能够支持流程控制、条件分支等功能，以更简单、高效的方式帮助我们编排同步/异步的工作流。

---

faas-flow的使用方法十分简单，具体使用内容在github中。

```
package main

import (
    "fmt"
    "github.com/s8sg/faas-flow"
)

func main() {
    f := flow.NewFlow("async-workflow")

    f.Apply("worker-1", map[string]interface{}{"message": "Hello, world!"})
    f.ApplyAsync("worker-2", nil)
    f.ApplyAsync("worker-3", nil)
    f.Apply("worker-4", nil)

    f.Then().Apply("worker-5", nil)

    f.Run()
}

func worker1(input map[string]interface{}) map[string]interface{} {
    message := input["message"].(string)
    fmt.Println("worker-1 received message:", message)
    return nil
}

func worker2(input map[string]interface{}) (string, error) {
    fmt.Println("worker-2 executing...")
    return "worker-2 completed", nil
}

func worker3(input map[string]interface{}) (string, error) {
    fmt.Println("worker-3 executing...")
    return "worker-3 completed", nil
}

func worker4(input map[string]interface{}) string {
    fmt.Println("worker-4 executing...")
    return "worker-4 completed"
}

func worker5(input map[string]interface{}) {
    fmt.Println("worker-5 executing...")
}

```

在这个示例中，我们定义了一个名为 “async-workflow” 的异步工作流，并在其中使用了 5 个函数。首先，我们在 worker-1 中向工作流中添加了一个包含 “Hello, world!” 消息的任务。然后，我们用 ApplyAsync 方法添加了两个异步任务 worker-2 和 worker-3。最后，我们在 worker-4 中添加了一个同步任务。

接下来，我们使用 Then 方法在 worker-4 任务完成时添加了一个 worker-5 任务，这个任务不需要输入参数。

最后，我们使用 Run 方法执行了整个工作流。

在函数实现方面，我们可以看到每个函数都需要接收一个类似于 map[string]interface{} 的输入参数，这个参数可以用来传递其他函数返回的数据。在 worker-1 中，我们使用断言将消息转换为字符串并将其打印到控制台。在 worker-2 和 worker-3 中，我们分别输出了一些文本并返回了一个字符串结果。在 worker-4 和 worker-5 中，我们只是输出了一些文本，没有返回任何结果。

对于异步工作流，并不会直接将结果输出给用户，因此可以使用OpenFaaS提供的回调机制来取回数据。具体步骤如下：

1. 在函数定义中添加回调 URL：

```
functions:
  my-function:
    lang: python
    handler: ./my-function
    annotations:
      callback_url: <https://my-callback-url.com/>

```

1. 在函数代码中，使用 `X-Callback-Url` 请求头向回调 URL 发送回调消息：

```
import requests

def handle(req):
    # Do some work...

    callback_url = req.get_header("X-Callback-Url")
    if callback_url:
        requests.post(callback_url, data=result)

```

在上面的示例中，我们从请求头中获取了回调 URL 并使用 requests 库将结果发送回去。

注意，回调 URL 必须是公网可用的 URL，因为 OpenFaaS 将通过互联网向该 URL 发送回调消息。